#!/bin/bash
#
# Usage
#   redmine list [options] [pjspec...]
#
# Description
#   Print task list to standard output. If you give pjspec as a parameter,
#   the tasks belonging to the specified project are printed.
#   If you give no parameter, tasks of all projects are printed.
#
# Options
#   -a user_id    filter ticket with given user (user ID or "me")
#   -c            show closed tickets
#   -C            hide closed tickets
#   -g            grouping by projects
#   -s            show subprojects
#   -h            show this message
#
# TODO:
#   - too slow

show_help() {
	sed -n 2,$[$BASH_LINENO-4]p $BASH_SOURCE | grep "^#" | sed 's/^#/ /'
}

PROJECT=all
GROUPING=
SHOW_SUBPROJECT=
while [[ $# -gt 0 ]] ; do
	key="$1"
	case $key in
		-a)
			ASSIGNED="$2"
			ASSIGNED_OPT="&assigned_to_id=$ASSIGNED"
			shift 2
			;;
		-c)
			RM_SHOW_CLOSED=true
			shift 1
			;;
		-C)
			RM_SHOW_CLOSED=false
			shift 1
			;;
		-g)
			GROUPING=true
			shift 1
			;;
		-s)
			SHOW_SUBPROJECT=true
			shift 1
			;;
		-h)
			show_help
			exit 0
			;;
		*)
			# echo "invalid option $key"
			break
			;;
	esac
done

[ -t 1 ] && . $THISDIR/color.sh
[ "$#" -gt 0 ] && PROJECT="$@"

rm $RM_CONFIG/tmp.local_ticket_list 2> /dev/null

generate_project_table PJTABLE
for ltck in $(get_local_ticket_list) ; do
	latest_clockout="$(tail -n1 $RM_CONFIG/edit_memo/$ltck/.clock.log | cut -f2 -d' ')"
	latest_clockout="$(date -d $latest_clockout +%y%m%d_%H%M)"
	subject="$(grep -i ^#\+subject: $RM_CONFIG/edit_memo/$ltck/draft.md | sed 's|^#+subject: *||i')"
	project="$(grep -i ^#\+project: $RM_CONFIG/edit_memo/$ltck/draft.md | sed 's|^#+project: *||i')"
	if [ ! "$project" ] ; then
		project=null
	else
		project=${PJTABLE[$project]}
	fi
	status="$(grep -i ^#\+status: $RM_CONFIG/edit_memo/$ltck/draft.md | sed 's|^#+status: *||i')"
	if status_closed "$status" ; then
		status="<${CL_BLUE}Local${CL_NC}|${CL_DGRAY}$status${CL_NC}>"
	else
		status="<${CL_BLUE}Local${CL_NC}|${CL_YELLOW}$status${CL_NC}>"
	fi

	[ ! "$status" ] && status=null
	echo -e "$ltck\t${latest_clockout}\t$project\t$status\t$subject" >> $RM_CONFIG/tmp.local_ticket_list
done

update_local_cache || exit 1

show_project_task_list() {
	local pjid="$1"

	echo "List of issues under project $pjid $(project_to_name $pjid):"
	local ifs="$IFS"
	IFS=$'\t'
	if [ "$RM_SHOW_CLOSED" = "true" ] ; then
		jq -r -c ".issues[] | select(.project.id == $pjid) | [.id, .updated_on, .project.name, .tracker.name, .status.name, .subject] | @tsv" $RM_CONFIG/issues.json | sort -k2 | while read id update project tracker status subject ; do
			printf "%s\t%s\t%s\t%s\t%s\n" "$id" "$(date -d $update +%y%m%d_%H%M)" "$project" "<$tracker|$status>" "$subject"
		done
	else
		jq -r -c ".issues[] | select((.project.id == $pjid) and (.closed_on == null)) | [.id, .updated_on, .project.name, .tracker.name, .status.name, .subject] | @tsv" $RM_CONFIG/issues.json | sort -k2 | while read id update project tracker status subject ; do
			printf "%s\t%s\t%s\t%s\t%s\n" "$id" "$(date -d $update +%y%m%d_%H%M)" "$project" "<$tracker|$status>" "$subject"
		done
	fi
	IFS="$ifs"
}

show_global_task_list() {
	local pjid="$@"

	local ifs="$IFS"
	IFS=$'\t'
	if [ "$RM_SHOW_CLOSED" = "true" ] ; then
		jq -r -c ".issues[] | [.id, .updated_on, .project.name, .tracker.name, .status.name, .subject] | @tsv" $RM_CONFIG/issues.json | sort -k2 | while read id update project tracker status subject ; do
			printf "%s\t%s\t%s\t%s\t%s\n" "$id" "$(date -d $update +%y%m%d_%H%M)" "$project" "<$tracker|$status>" "$subject"
		done
	else
		jq -r -c ".issues[] | select(.closed_on == null) | [.id, .updated_on, .project.name, .tracker.name, .status.name, .subject] | @tsv" $RM_CONFIG/issues.json | sort -k2 | while read id update project tracker status subject ; do
			printf "%s\t%s\t%s\t%s\t%s\n" "$id" "$(date -d $update +%y%m%d_%H%M)" "$project" "<$tracker|$status>" "$subject"
		done
	fi
	IFS="$ifs"
}

if [ "$SHOW_SUBPROJECT" ] ; then
	get_project_table $RM_CONFIG/projects.json
	if [ "$PROJECT" = all ] ; then
		PROJECT="$(cat $TMPDIR/top_level_projects)"
	else
		PROJECT="$(pjspec_to_pjid $PROJECT)"
	fi
	PROJECT="$(get_subproject_list $PROJECT)"
else
	if [ "$PROJECT" == all ] ; then
		PROJECT="$(jq -r ".projects[] | .id" $RM_CONFIG/projects.json | sort -k1n)"
	else
		PROJECT="$(pjspec_to_pjid $PROJECT)"
	fi
fi

if [ "$GROUPING" = true ] ; then
	for pjspec in $PROJECT ; do
		pjid=$(pjspec_to_pjid $pjspec) || exit 1
		show_project_task_list $pjid >> $TMPDIR/out
	done
	cat $TMPDIR/out | expand
else
	# TODO: filter with given projects
	show_global_task_list $PROJECT > $TMPDIR/out
	cat $TMPDIR/out | column -t -s $'\t'
fi

